# **План разработки требований**

## Этап 0: Подготовительный

1. Погуглить работу с регулярными выражениями для понимания (R1.1, R1.2)
2. Погуглить про безопасное хранение паролей
    - хеш
    - соль
    - типы шифрования
3. Погуглить структуру дерева в kotlin (R1.4)
4. Создать репозиторий открытый в git 
5. Создать консольное приложение проект в IDEA (R1.8)
6. Написать bash скрипт сборки приложения `build.sh` (R1.12)
7. Написать bash скрипт запуск приложения `run.sh` (R1.12)

## Этап 1: Работа с консольными параметрами 
1. Написать тесты на падачу параметров командной строки (R1.12)
    1. Взять тестовые входные данные:
        - печать справки: `-h` — 1
        - печать справки: `` - , 1
        - печать справки: `-photo` — 1
        - аутентификация: `-login` sasha `-pass` qwery — 0
        - авторизация: `-login` sasha `-pass` qwery `-res` A.B `-role` READ — 0
        - аккаунтинг: `-login` sasha `-pass` qwery `-res` A.B `-role` READ `-ds` 2000-01-01 `-de` 2000-01-01 `-vol` 19 — 0 
        - аккаунтинг: `-vol` 19 `-de` 2000-01-01 `-res` A.B `-ds` 2000-01-01 `-role` READ `-pass` qwery `-login` sasha — 0 
    2. Написать `bash` скрипт `test.sh`, запускающий программу с тестовыми данными и проверяющий код работы программы с ожидаемым.
    3. Опубликовать изменения в git 
2. Написать `main`, считывающий параметры (R1.8):
    - печать справки (R1.8.1, R1.8.2, R1.8.6)
    - обработка в любом порядке (R1.10)
    - возвращаение статуса 0 при правильных параметрах
    - возвращение статуса 1 при вызове справки
3. Протестировать реализацию автотестами п.1 (R1.12)
4. Обновить автотесты, если требуется (R1.12)
5. Опубликовать изменения в git

## Этап 2: Аутентификация пользователя
1. Написать тесты на авторизацию (R1.12)
    1. Взять тестовые данные
        - Успешная авторизация: `user mypassword` — 0 
        - Неверный формат логина(цывры):`666user666 newpassword` — 2
        - Неверный формат логина(цифры, прописные): `uSeR2000 pass500p` — 2
        - Неверный формат логина(количество >10): `useranduser pass500p` — 2
        - Неверный формат логина(пустой): ` pass500p` — 2
        - Невеизвестный логин: `useradmin password` — 3
        - Неверный пароль: `user password` — 4
        - Неверный пароль(пустой): `user` — 4
    2. Написать `bash` скрипт `test.sh`, запускающий программу с тестовыми данными и проверяющий код работы программы с ожидаемым.
    3. Опубликовать изменения в git 
2. Создать `data class User` с логином и паролем (R1.1)
3. Свалидировать логина на формат `[a-z]{1-10}` (код ошибки 2 R1.9, R1.8.3)
4. Создать класс `Autentification` для аутентификации пользователя по логину и паролю (R1.1)
    1. Поиск по логину пользователя (код 3, если не найден (R1.9))
    2. Получение хеша по паролю
    3. Сравнение хешей (0 — успех, 4 — не успех (R1.9))
5. Протестировать реализацию автотестами п.1 (R1.12)
6. Обновить автотесты, если требуется (R1.12)
7. Опубликовать изменения в git

## Этап 3: Авторизация
1. Написать тесты на вторизацию (R1.12)
    1. Взять тестоыве данные
        - Успешная авторизация по логину, паролю и роли `READ`: `user mypassword read A.B.D` — 0
        - Успешная авторизация по логину, паролю и роли `WRITE`: `author mypass write A.B.C` — 0
        - Успешная авторизация по логину, паролю и роли `EXECUTE`: `admin admin execute A.B.C` — 0
        - Повторить неагитивные тесты на коды 2-3-4 для роли read, write и execute — 2,3,4 соответственно
        - Неизвестная роль: `admin admin admin A.B.C` — 5
        - Неизвестная роль - пустая: `admin admin A.B.C` — 5
        - Нет доступа: `user mypassword execute A.B.C` — 6
        - Нет доступа(ресурс пустой): `user mypassword execute` — 6
    2. Дописать `bash` скрипт `test.sh` с тестами 
    3. Опубликовать изменения в git
2. Создать `data class Resource` (R1.3, R1.6)
3. Создать перечисление `enum Role` (R1.3,R1.5)
4. Добавить структуру со связью между ресурсом, пользователем и ролью
5. Создать класс `Authorization` (R1.3)
    - поиск ресурса
    - проверка доступа к ресурсу (R1.3, R1.4, R1.6), определяя уровень доступа по дереву, возврат кода 6, если доступа нет (R1.9)
6. Дописать чтение параметрами `res`, `role` (R1.8.4)
    - Проверка формата ресурса (R1.3)
    - Проверку роли по списку (R1.5, R1.8.4)
7. Протестировать реализацию автотестами п.1 (R1.12)
8. Обновить автотесты, если требуется (R1.12)
9. Опубликовать изменения в git

## Этап 4: Аккаунтинг
1. Написать тесты на вторизацию (R1.12)
    1. Взять тестоыве данные
        - Успешно, верные даты и объем: `user mypassword read A.B.D 2000-12-11 2000-12-12 7` — 0
        - Некорректная активность, не приводятся ds: `user mypassword read A.B.D 2000-20-101 2000-12-12 7` — 7
        - Некорректная активность, не приводятся de: `user mypassword read A.B.D 2000-12-10 2000-100-102 7` — 7
        - Некорректная активность, не приводятся vol: `user mypassword read A.B.D 2000-12-10 2000-100-102 seven` — 7
        - Некорректная активность, не приводятся vol(пустое значение): `user mypassword read A.B.D 2000-12-10 2000-100-102 ` — 7
        - Некорректная активность, не приводятся de, ds vol(пустое значение): `user mypassword read A.B.D ` — 7
    2. Дописать bash скрипт `test.sh` с тестами 
    3. Опубликовать изменения в git
2. Создать хранилку сессии пользователя (R1.7)
    1. Записывать подключение (`ds de`)
    2. Сохранять заправшиваемый ресурс
    3. Сохранять запрашиваемый объем
3. Дописать чтение параметрами `ds`, `de`, `vol` (R1.8.5)
    - Проверка формата дат
    - Проверка последовательности дат `ds` раньше `de`
    - Проверка формата объема `int`
    - возврат кода 7, в случае ошибки (R1.9)
4. Протестировать реализацию автотестами (R1.12)
5. Обновить автотесты, если требуется (R1.12)
6. Опубликовать изменения в git

## Этап 5: Сборка требований
1. Написать процесс AAA (R1.11)
    1. Сначала аутентификацию (два параметра и более)
    2. Если успешно, переходим к авторизации (четыре параметра и более)
    3. Если успешно, переходим к аккаунтингу (семь параметров)
2. Запустить автотесты
3. Опубликовать изменения в git
4. Обновить readme 
